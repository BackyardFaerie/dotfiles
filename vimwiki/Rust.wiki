# Variables and Constants
1: Variables defined via
	<code>let x = value;</code>

2: All vars are immutable by default, explicit mut is required to make them mutable
	<code>let mut x = value;</code>

3: You can **ONLY** assign values to mutable variables of the correct type e.g chars/strings cannot be assigned to integers
	<code>let mut x = 5;
	let x = 'd';</code>

4: Contrary to above, immutable vars when redeclared create a new var (even in same scope) and can even be of a different data type, note as above that this is **NOT** applicable to mutable vars
	<code>Legal		Illegal
	let x = 5;		let mut x = 5;
	...			...
	let x = string;		let x = string;</code>
Mutable vars can change **VALUE** within a scope but *NOT DATA TYPE*
In the above example, if x was redeclared as an integer it could also call the previous value of x which was 5 and be let x = x + 12 and that doesn't give a compiler error. This is not shadowing because the two vars (confusingly both called x)
are within the same scope, it _would_ be shadowing if they were in _different_ scopes. I think mutable vars are unable to be redeclared, since their value can change over time but they remain the same var in runtime where immutable vars are
able to be redeclared since their values don't change over time so another var can be stored in runtime despite both being x to the user which would lead to this behaviour. This is different to constants because they can never change their
value or data type in the entire program

5: Variables are implicitly assigned a data type if no explicit type is given
	<code>Implicit	Explicit
	let x = 6;	let x:u8 = 6;
</code>
6: Variables can be embedded into strings with <code>("{}", x)</code> as below
	<code>println!("Some words {}, x);</code> or <code>println!("x is equal to {x}");</code>
I think the println macro is a function here judging by the () meaning maybe the {} is a scope or maybe it is to give the compiler a place to assign the var like an array or something but I'm not sure

7: Redeclaring a var of the same name within the same scope is allowed, it creates another var of the same name with a different value **ONLY** if neither is mut (What? This is confusing and something to look into further, maybe they take up different locations in memory?)
	Legal
<code>	let x = 5;
	...
	let x = 12;
</code>
8: Constants defined as below. Unlike vars, consts can **NEVER** change data type or value 
<code>	const CONST_EXAMPLE: u32 = 18;</code>

9: [[https://en.wikipedia.org/wiki/Local_variable|Local variables]] must be known at compile time because they take up a set amount of memory

10: Variables being used by functions cannot be used/borrowed until they are explicitly returned, in the below example the divide_nums function cannot use x until the multiply_nums function has returned it
	<code>fn multiply_nums(int: i32) -> int32 {
	let x:i32 = 5;
	...
	}
	
	fn divide_nums(int: i32) -> i32 {
	...
	}
</code>^Borrowed references are READ ONLY meaning no operations other than reading can be performed on them^

# Scope
1: Scope is generally anything contained within {}

2: Having a scope inside of another is allowed
<code>fn main() {
let x = value;
...
	{
	...
	}

}</code>

3: Redeclaring a var from another scope with a different value is shadowing

# Shadowing
1: Redeclaring a var from another scope with a different value is shadowing, this does not give a compiler error
<code>	fn main(){
	let x = 1;
		{</code> <---internal scope begin
		<code>let x = 3;</code> <---shadowing (note {} is internal scope but calling x from parent scope, x here calls from the parent scope and sets a value in this interior scope and therefore *IS* shadowing)
		<code>}</code> <---internal scope end
<code>	let x = 2;</code> <---**NOT** shadowing (this line is in the parent scope of main(){} as is x = 1, the scope is the same and therefore is *NOT* shadowing)
	<code>}
</code>
# Control Flow, If/Else/Else if Statements and Blocks
1: If statements can be stacked and nested within each other
    <code>if fizzish == "fizz" {return "foo";}
    if fizzish == "fuzz" {return "bar";}
    else {return "baz";}</code>
Note that switch or match statements are better suited to this purpose of comparing a few conditions

2: Else if statements require an if statement before them

3: Else statements require if statement(s) and/or optional else if before them

4: The return value of a conditional is placed within {}, <code>return</code> is not needed unless an early return is desired

5: Iterating over values in an array or vector can have the same operation applied to each element with <code>+=</code> or <code>*=</code> (possibly /= and -=?). In the example below <code>values</code> of the vector are doubled.
The <code>.iter_mut()</code> method is only there because the vector is mutable, I believe there is also a <code>.iter()</code> for immutable data e.g an array
	<code>for values in vector.iter_mut() {
	*values *= 2
	}</code>
	
# Arrays/Slices
1: Declare arrays as follows
	<code>let arrayName: [dataType; size] = [val1, val2, val3];</code>

2: Array sizes, traits and other [[https://en.wikipedia.org/wiki/Local_variable|local variables]] must be known at compile time since they can only take up a certain amount of memory and this must be known when compiling

3: Slices are very usually  [[https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html|borrowed references]] due to taking a known amount of memory since they are effectively just pointers
	<code>let sliceName: &[dataType] = &[assignedValue];</code>
^Remember that borrowed references are READ ONLY^

#  Tuples
1: [[https://doc.rust-lang.org/book/ch03-02-data-types.html#the-tuple-type|Tuples]] combine data types into one variable (like an array of various data types)

2: Declare tuples as follows
	<code>let tup: (dataType1, dataType2, dataType3) = (val1, val2, val3);</code> <---like variables, explicitly listing data types is optional. If data types are not explicitly given do not include <code>:</code>

3: Tuples **CANNOT** change size

4: Tuple indices can be referenced with {index}, naturally the tuple must be declared first
	Example
	<code>let value = {index};</code>
	
# Vectors
1: Declare vectors in one of the two following ways
	<code>let vectorName = vec![];</code> OR <code>Vec::new()</code> then fill with <code>.push()</code> method
^In the macro, the values in <code>[]</code> are the initial values of the vector, I think it is the same for <code>()</code> in <code>Vec::new</code>. Values can later be <code>.push()</code>ed to append them to the end^

2: [[https://doc.rust-lang.org/stable/book/ch08-01-vectors.html|Vectors]] store multiple values but **ALL MUST** be of the **SAME** data type unlike tuples

3: The values of a vector are stored together in memory (in the stack?)
	<code>data1, data2, VectorValue1, VectorValue2, VectorValue3, data3, data4...</code>

4: 
